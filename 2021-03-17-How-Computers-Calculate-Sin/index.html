<!DOCTYPE html><html lang="en" data-theme="light"><head><meta content="utf-8" name="charset"></meta><meta content="width=device-width, initial-scale=1, maximum-scale=5" name="viewport"></meta><meta content="only light" name="color-scheme"></meta><title>Khan's Blog · How Computers Calculate Sine</title><meta content="Sine is infinite, so how can a computer calculate an infinite function?" name="description"></meta><meta content="all" name="robots"></meta><meta content="Khan Winter, Swift, macOS, JavaScript, iOS, web development, blog, SwiftUI" name="keywords"></meta><meta content="website" property="og:type"></meta><meta content="Khan's Blog" property="og:sitename"></meta><meta content="https://khanwinter.com/2021-03-17-How-Computers-Calculate-Sin/" property="og:url"></meta><meta content="Khan's Blog · How Computers Calculate Sine" property="og:title"></meta><meta content="Sine is infinite, so how can a computer calculate an infinite function?" property="og:description"></meta><meta content="https://khanwinter.com/2021-03-17-How-Computers-Calculate-Sin/" property="twitter:url"></meta><meta content="Khan's Blog · How Computers Calculate Sine" property="twitter:title"></meta><meta content="Sine is infinite, so how can a computer calculate an infinite function?" property="twitter:description"></meta><link href="https://khanwinter.com/2021-03-17-How-Computers-Calculate-Sin/" rel="canonical"/><link href="https://bsky.app/profile/khanwinter.com" rel="me"/><link href="https://twitter.com/thecoolwinter" rel="me"/><link href="https://mastodon.social/@thecoolwinter" rel="me"/><link href="https://threads.net/thecoolwinter" rel="me"/><link href="https://www.linkedin.com/in/thecoolwinter/" rel="me"/><link href="/assets/index.css" rel="stylesheet"/><script src="/assets/index.js"></script><link href="/assets/prism.css" rel="stylesheet"/><link href="/assets/code-theme.css" rel="stylesheet"/><script defer src="/assets/prism.js"></script><link data-nav="true" href="/" rel="prefetch"/><link data-nav="true" href="/about" rel="prefetch"/><link data-nav="true" href="/2025-03-29-Cross-Compiling-Swift/" rel="prefetch"/><link data-nav="true" href="/2024-11-02-New-Blog/" rel="prefetch"/><link data-nav="true" href="/2024-11-01-Hide-Desktop-Shortcut/" rel="prefetch"/><link data-nav="true" href="/2021-08-07-Sort-List-Of-Objects/" rel="prefetch"/><link data-nav="true" href="/2021-05-08-Implementing-Sin/" rel="prefetch"/><link data-nav="true" href="/2021-03-17-How-Computers-Calculate-Sin/" rel="prefetch"/><link data-nav="true" href="/2021-02-02-The-Search-Engine-Matrix/" rel="prefetch"/><link data-nav="true" href="/2021-01-07-Save-Codable-Dates-In-Firestore/" rel="prefetch"/><link data-nav="true" href="/2020-05-5-Scripting-With-Swift/" rel="prefetch"/><link data-nav="true" href="/2020-02-24-Programatic-UI-In-UIKit-Without-Storyboards/" rel="prefetch"/><link data-nav="true" href="/2020-11-04-Getting-Started-With-Vapor-4/" rel="prefetch"/><link data-nav="true" href="/2019-12-17-Save-Array-Of-Any-Object-In-Realm/" rel="prefetch"/><link data-nav="true" href="/2020-05-11-Subclassing-Sprites-In-SpriteKit/" rel="prefetch"/><link data-nav="true" href="/2020-05-5-Using-Dependencies-In-Swift-Scripts/" rel="prefetch"/><link data-nav="true" href="/2020-02-21-Easy-Container-Controllers-in-Swift/" rel="prefetch"/><link data-nav="true" href="/2019-12-19-Firebase-Auth-State-Listeners-iOS/" rel="prefetch"/></head><body><nav><ul><li><a href="/index.html">Posts</a></li><li><button onclick="navRandom()">Random</button></li><li><a href="/about.html">About</a></li></ul></nav><div class="content"><article><div class="article-header"><p>Mar 17, 2021</p><h1>How Computers Calculate Sine</h1><h3>Sine is infinite, so how can a computer calculate an infinite function?</h3><div class="avatar" href="/about.html"><a href="/about.html"><img alt="Avatar Image" height="24" src="/assets/avatar.webp" width="24"></img><span>Khan Winter</span></a>·<a href="https://bsky.app/profile/khanwinter.com" target="_blank"><svg aria-label="Bluesky" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 530" version="1.1"><path d="m135.72 44.03c66.496 49.921 138.02 151.14 164.28 205.46 26.262-54.316 97.782-155.54 164.28-205.46 47.98-36.021 125.72-63.892 125.72 24.795 0 17.712-10.155 148.79-16.111 170.07-20.703 73.984-96.144 92.854-163.25 81.433 117.3 19.964 147.14 86.092 82.697 152.22-122.39 125.59-175.91-31.511-189.63-71.766-2.514-7.3797-3.6904-10.832-3.7077-7.8964-0.0174-2.9357-1.1937 0.51669-3.7077 7.8964-13.714 40.255-67.233 197.36-189.63 71.766-64.444-66.128-34.605-132.26 82.697-152.22-67.108 11.421-142.55-7.4491-163.25-81.433-5.9562-21.282-16.111-152.36-16.111-170.07 0-88.687 77.742-60.816 125.72-24.795z"/></svg></a></div></div><link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" integrity="sha384-nB0miv6/jRmo5UMMR1wu3Gz6NLsoTkbqJghGIsx//Rlm+ZU03BU6SQNC66uf4l5+" rel="stylesheet"></link><script crossorigin="anonymous" defer integrity="sha384-7zkQWkzuo3B5mTepMUcHkMB5jZaolc2xDwL6VFqjFALcbeS9Ggm/Yr2r3Dy4lfFg" src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script><script crossorigin="anonymous" defer integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"></script><script>document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
        delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false},
        ],
        throwOnError : true
    });
});</script><h2 id="computers-arent-infinite"><a href="#computers-arent-infinite" class="header-link">Computers aren't infinite.</a></h2><p>How can computers compute <em>(no pun intented)</em> infinite functions like sin so fast? Take video games for instance, that need to compute trig functions incredibly fast 100's of times a second to render frames. If sine and cosine took long at all, we would never have video games.</p><p>How do computers do it?</p><hr><p>Historically computer scientists have two ways of getting around this problem.</p><ol><li>Store a table of sine and cosine values, then reference that table whenever you need. Java does this, and it works fairly well until you need a value of sine that isn't in the table</li><li>Estimate <span class="math-inline">$sin(x)$</span> using another function.</li></ol><p>Here I'll show you how computers estimate sin for any value.</p><h2 id="sine-and-derivatives"><a href="#sine-and-derivatives" class="header-link">Sine and derivatives</a></h2><p><strong>Before we take a deeper dive into the math, there's two concepts we need to understand.</strong></p><hr><h3 id="sine"><a href="#sine" class="header-link">Sine</a></h3><p>For a little background I'll start by explaining two important concepts. First, <span class="math-inline">$sin(x)$</span>. You may remember this fun function from a high school algebra class. <span class="math-inline">$sin(x)$</span> has these important properties.</p><ol><li>Sine is infinite, meaning it'll have a value at any number you put into it.</li><li>It's also periodic, which means that it repeats itself over and over again (like a wave).</li></ol><p>Here's a graph of <em>y=sin(x)</em>.</p><img src="1.png" alt="y=sin(x)"/><p>As you can see, the value of <em>sin(x)</em> goes up and down between <span class="math-inline">$-1$</span> and <span class="math-inline">$1$</span>.</p><p>You can also tell that it's not coming to an end. It'll go on forever from −&infin; all the way to +&infin;.</p><p><strong>One more important thing about sine is that the curve 0 to <span class="math-inline">$\frac{\pi}{2}$</span> is repeated on the entire rest of sine. The curve might be backwards or upside down, but it's always exactly the same.</strong></p><p><strong>That means if we can figure out values for any point in <span class="math-inline">$0$</span> to <span class="math-inline">$\frac{\pi}{2}$</span>, we can figure out points for anywhere on sine.</strong></p><hr><h3 id="derivatives"><a href="#derivatives" class="header-link">Derivatives</a></h3><p>A derivative is the core concept of Calculus. Basically, when you take a derivative of a function, you create another function that measures the <em>rate of change</em> of the original function. It can be confusing, but a really good example of this comes from physics.</p><p>If we have a particle that's moving according to the position function</p><span class="math-block">$$
x=vt+\frac{1}{2}at^2
$$</span><p>We can take the <strong><em>Derivative</em></strong> of that funciton, to get</p><span class="math-block">$$
v=at
$$</span><p><strong><em>Velocity</em></strong> is the derivative of the position function. It's literally, <em>the change in position over time</em>. We can even take the derivative of Velocity to get</p><span class="math-block">$$
a=\left(some\:number\right)
$$</span><p><strong><em>Acceleration</em></strong>. Acceleration is <em>the change in velocity over time</em>.</p><p>Here's a graph of all these functions over time. You'll notice the velocity is going up at a constant rate <em>a</em>, and the position is going up exponentially. If we dropped a ball off a cliff. The ball would fall faster over time, so the velocity would steadily increase, but the acceleration would always be <em><span class="math-inline">$9.81\frac{m}{s^2}$</span></em>.</p><img src="derivatives.png" alt="Derivatives"/><p>Finally, derivatives are shown using this syntax <span class="math-inline">$
derivative\:of\:f\left(x\right)=f'\left(x\right)
$</span> So from now on, if you see <em>f'(x)</em> that's the derivative of the function <em>f</em>. If we add more <em>'</em> to the function if grows in derivatives. So the second derivative of <em>f</em> is <span class="math-inline">$
second\:derivative\:of\:f\left(x\right)=f''\left(x\right)second\:derivative\:of\:f\left(x\right)=f''\left(x\right)
$</span></p><hr><h2 id="how-do-we-use-derivatives-to-calculate-sine"><a href="#how-do-we-use-derivatives-to-calculate-sine" class="header-link">How do we use derivatives to calculate sine?</a></h2><h3 id="a-taylor-series"><a href="#a-taylor-series" class="header-link">A: Taylor Series</a></h3><p>Taylor series estimate a function. Basically, a mathemetician named Brook Taylor realized that any function is equal to this sum</p><span class="math-block">$$
f\left(x\right)=f\left(0\right)+\frac{f'\left(0\right)}{1!}x+\frac{f''\left(0\right)}{2!}x^2+...
$$</span><p>Each part that we're adding up is the <span class="math-inline">$nth$</span> derivative of <em>f</em> divided by the number <em>n!</em> it's at, times <span class="math-inline">$x^n$</span>. If we add up infinity of these functions, this Taylor series will be perfectly equal to <span class="math-inline">$f(x)$</span>.</p><blockquote><p>Each time we add one of the parts above, we're adding a <em>degree</em> to the Taylor series. So the above function is to the 3rd degree.</p></blockquote><p>Taylor series work on the idea that the function is related to it's derivatives somehow. So we can get the initial value of <span class="math-inline">$f(x)$</span> at <span class="math-inline">$f(0)$</span>, and the next derivative <span class="math-inline">$f'(x)$</span> gives us the direction it should go next. Each derivative we add in this way points the Taylor series in the correct direction more and more until it's exactly equal to the entire original function.</p><hr><p>But, we don't always have to add up to infinity. In fact, the series is very close to <span class="math-inline">$f(x)$</span> for a short bit after only a few sums of the Taylor series.</p><p>This comes in handy if say, we only need to know values for a specific part of the function say <em>*ahem*</em> 0 to <span class="math-inline">$\frac{\pi }{2}$</span>.</p><p>In fact, this is the Taylor series to the 7th degree, which happens to equal <span class="math-inline">$sin(x)$</span> nearly exactly from <span class="math-inline">$0$</span> to <span class="math-inline">$\frac{\pi }{2}$</span>.</p><span class="math-block">$$
sin(x)=x-\frac{x^3}{3!}+\frac{x^5}{5!}-\frac{x^7}{7!}+\frac{x^{11}}{11!}-\frac{x^{13}}{13!}+\frac{x^{15}}{15!}
$$</span><img src="taylor-sin.png" alt="Taylor Series of Sin"/><p>The graph above shows that the Taylor series is equal to <span class="math-inline">$sin(x)$</span> until <span class="math-inline">$\frac{\pi}{4}$</span>, where it starts to wander.</p><h2 id="computer-time"><a href="#computer-time" class="header-link">Computer time!</a></h2><p>Now we have a function we can use to estimate <span class="math-inline">$sin(x)$</span> anywhere along <span class="math-inline">$sin(x)$</span>.</p><p>Since the function isn't infinite, we can translate it to a computer function very easily. Heres <code>sin(x)</code> in Swift.</p><pre><code class="language-swift">let S1 = -1.66666666666666324348e-01;  // -1/(3!)
let S2 = 8.3333333332248946124e-03;    //  1/(5!)
let S3 = -1.98412698298579493134e-04;  // -1/(7!)
let S4 = 2.75573137070700676789e-06;   //  1/(9!)
let S5 = -2.50507602534068634195e-08;  // -1/(11!)
let S6 = 1.58969099521155010221e-10;   //  1/(13!)

func usersin(_ x: Double) -&gt; Double {
    let z = x*x                          // x^2
    let v = z*x                          // x^3
    let r = S2+z*(S3+z*(S4+z*(S5+z*S6))) // Taylor function part 1/2
    return x+v*(S1+z*r)                   // Taylor function part 2/2
}
</code></pre><p>Here's how this works.</p><ol><li>First, we're storing the larger numbers at the top. These numbers are constants, so we can set them statically outside the function.</li><li>The variables <code>z</code>, and <code>v</code> are placeholder variables for powers of <code>x</code>, they're there mostly for readability</li><li><code>r</code> is the first part of the actual Taylor function. I found that if I kept the entire polynomial in one declaration it messed up the final result.</li><li>We return the final Taylor function.</li></ol><p>To test this implementation, we can import <code>Foundation</code> and compare it to Swift's built-in <code>sin</code>.</p><pre><code class="language-swift">#!/usr/bin/swift

import Foundation

let S1 = -1.66666666666666324348e-01;  // -1/(3!)
let S2 = 8.3333333332248946124e-03;    //  1/(5!)
let S3 = -1.98412698298579493134e-04;  // -1/(7!)
let S4 = 2.75573137070700676789e-06;   //  1/(9!)
let S5 = -2.50507602534068634195e-08;  // -1/(11!)
let S6 = 1.58969099521155010221e-10;   //  1/(13!)

func usersin(_ x: Double) -&gt; Double {
    let z = x*x                          // x^2
    let v = z*x                          // x^3
    let r = S2+z*(S3+z*(S4+z*(S5+z*S6))) // Taylor function part 1/2
    return x+v*(S1+z*r)                   // Taylor function part 2/2
}

func printUserSin(_ input: Double, name: String) {
    print("x\t=\t\(name)")
    print("usersin(x):\t\(usersin(input))")
    print("sin(x):\t\t\(sin(input))")
    print("")
}
printUserSin(Double.pi/6, name: "Pi/6")
printUserSin(Double.pi/8, name: "Pi/8")
printUserSin(Double.pi/21, name: "Pi/21")
printUserSin(Double.pi/2, name: "Pi/2")
printUserSin(Double.pi/2 - 0.01, name: "Pi/2 - 0.01")
</code></pre><p>Which spits out:</p><pre><code class="language-bash">x	=	Pi/6
usersin(x): 0.4999999999999961
sin(x):     0.49999999999999994

x	=	Pi/8
usersin(x): 0.38268343236508884
sin(x):     0.3826834323650898

x	=	Pi/21
usersin(x): 0.14904226617617444
sin(x):     0.14904226617617444

x	=	Pi/2
usersin(x): 1.000000000251294
sin(x):     1.0

x	=	Pi/2 - 0.01
usersin(x): 0.9999500006418387
sin(x):     0.9999500004166653
</code></pre><p>Which is <strong>nearly</strong> completely accurate for all the values we gave it, plenty close for any calculation we may need, and plenty fast as well!</p><h2 id="conclusion"><a href="#conclusion" class="header-link">Conclusion</a></h2><p>I've shown a very naive implementation of <span class="math-inline">$sin(x)$</span>. It doesn't take into account values outside of <span class="math-inline">$0$</span> to <span class="math-inline">$\frac{\pi}{2}$</span> and doesn't account for negative values. In fact, this is the bare minimum you would want from a <code>sin</code> function.</p><p>In a future post I'll go over some of the tricks computer scientists have used to get around those problems, and compare speeds of this function with C and C++.</p><blockquote><p>If you'd like to run the code above on your own, create a file called <code>main.swift</code> and copy-paste the code into that file. Then run<code>chmod +x main.swift &amp;&amp; ./main.swift</code> to run the script.</p></blockquote><hr></hr><div class="article-footer"><p>Mar 17, 2021</p><div class="avatar" href="/about.html"><a href="/about.html"><img alt="Avatar Image" height="24" src="/assets/avatar.webp" width="24"></img><span>Khan Winter</span></a>·<a href="https://bsky.app/profile/khanwinter.com" target="_blank"><svg aria-label="Bluesky" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 530" version="1.1"><path d="m135.72 44.03c66.496 49.921 138.02 151.14 164.28 205.46 26.262-54.316 97.782-155.54 164.28-205.46 47.98-36.021 125.72-63.892 125.72 24.795 0 17.712-10.155 148.79-16.111 170.07-20.703 73.984-96.144 92.854-163.25 81.433 117.3 19.964 147.14 86.092 82.697 152.22-122.39 125.59-175.91-31.511-189.63-71.766-2.514-7.3797-3.6904-10.832-3.7077-7.8964-0.0174-2.9357-1.1937 0.51669-3.7077 7.8964-13.714 40.255-67.233 197.36-189.63 71.766-64.444-66.128-34.605-132.26 82.697-152.22-67.108 11.421-142.55-7.4491-163.25-81.433-5.9562-21.282-16.111-152.36-16.111-170.07 0-88.687 77.742-60.816 125.72-24.795z"/></svg></a></div></div></article></div><footer><p>Copyright &copy Khan Winter 2025</p><p><a href="https://github.com/thecoolwinter/blog">Built In Swift</a></p><p><a href="https://bsky.app/profile/khanwinter.com" rel="me" target="_blank">Bluesky</a> | <a href>RSS</a></p></footer></body></html>