<!DOCTYPE html><html lang="en" data-theme="light"><head><meta content="utf-8" name="charset"></meta><meta content="width=device-width, initial-scale=1, maximum-scale=5" name="viewport"></meta><meta content="only light" name="color-scheme"></meta><title>Khan's Blog · Using OpenType Attributes with UIFont</title><meta content="Fonts come with numerous style settings that are difficult to use in UIKit and AppKit. Learn how to determine which ones are available, and how to use them." name="description"></meta><meta content="all" name="robots"></meta><meta content="Khan Winter, Swift, macOS, JavaScript, iOS, web development, blog, SwiftUI" name="keywords"></meta><meta content="website" property="og:type"></meta><meta content="Khan's Blog" property="og:sitename"></meta><meta content="https://khanwinter.com/2026-02-06-OpenType-UIFont" property="og:url"></meta><meta content="Khan's Blog · Using OpenType Attributes with UIFont" property="og:title"></meta><meta content="Fonts come with numerous style settings that are difficult to use in UIKit and AppKit. Learn how to determine which ones are available, and how to use them." property="og:description"></meta><meta content="https://khanwinter.com/2026-02-06-OpenType-UIFont" property="twitter:url"></meta><meta content="Khan's Blog · Using OpenType Attributes with UIFont" property="twitter:title"></meta><meta content="Fonts come with numerous style settings that are difficult to use in UIKit and AppKit. Learn how to determine which ones are available, and how to use them." property="twitter:description"></meta><link href="https://khanwinter.com/2026-02-06-OpenType-UIFont" rel="canonical"/><link href="https://bsky.app/profile/khanwinter.com" rel="me"/><link href="https://twitter.com/thecoolwinter" rel="me"/><link href="https://mastodon.social/@thecoolwinter" rel="me"/><link href="https://threads.net/thecoolwinter" rel="me"/><link href="https://www.linkedin.com/in/thecoolwinter/" rel="me"/><link href="/assets/index.css" rel="stylesheet"/><script src="/assets/index.js"></script><link href="/assets/prism.css" rel="stylesheet"/><link href="/assets/code-theme.css" rel="stylesheet"/><script defer src="/assets/prism.js"></script><link data-nav="true" href="/" rel="prefetch"/><link data-nav="true" href="/about" rel="prefetch"/><link data-nav="true" href="/2026-02-06-OpenType-UIFont" rel="prefetch"/><link data-nav="true" href="/2025-03-29-Cross-Compiling-Swift" rel="prefetch"/><link data-nav="true" href="/2024-11-02-New-Blog" rel="prefetch"/><link data-nav="true" href="/2024-11-01-Hide-Desktop-Shortcut" rel="prefetch"/><link data-nav="true" href="/2021-08-07-Sort-List-Of-Objects" rel="prefetch"/><link data-nav="true" href="/2021-05-08-Implementing-Sin" rel="prefetch"/><link data-nav="true" href="/2021-03-17-How-Computers-Calculate-Sin" rel="prefetch"/><link data-nav="true" href="/2021-02-02-The-Search-Engine-Matrix" rel="prefetch"/><link data-nav="true" href="/2021-01-07-Save-Codable-Dates-In-Firestore" rel="prefetch"/><link data-nav="true" href="/2020-05-5-Scripting-With-Swift" rel="prefetch"/><link data-nav="true" href="/2020-02-24-Programatic-UI-In-UIKit-Without-Storyboards" rel="prefetch"/><link data-nav="true" href="/2020-11-04-Getting-Started-With-Vapor-4" rel="prefetch"/><link data-nav="true" href="/2019-12-17-Save-Array-Of-Any-Object-In-Realm" rel="prefetch"/><link data-nav="true" href="/2020-05-11-Subclassing-Sprites-In-SpriteKit" rel="prefetch"/><link data-nav="true" href="/2020-05-5-Using-Dependencies-In-Swift-Scripts" rel="prefetch"/><link data-nav="true" href="/2020-02-21-Easy-Container-Controllers-in-Swift" rel="prefetch"/><link data-nav="true" href="/2019-12-19-Firebase-Auth-State-Listeners-iOS" rel="prefetch"/></head><body><nav><ul><li><a href="/index.html">Posts</a></li><li><button onclick="navRandom()">Random</button></li><li><a href="/about.html">About</a></li></ul></nav><div class="content"><article><div class="article-header"><p>Feb 6, 2026</p><h1>Using OpenType Attributes with UIFont</h1><h3>Fonts come with numerous style settings that are difficult to use in UIKit and AppKit. Learn how to determine which ones are available, and how to use them.</h3><div class="avatar" href="/about.html"><a href="/about.html"><img alt="Avatar Image" height="24" src="/assets/avatar.webp" width="24"></img><span>Khan Winter</span></a>·<a href="https://bsky.app/profile/khanwinter.com" target="_blank"><svg aria-label="Bluesky" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 530" version="1.1"><path d="m135.72 44.03c66.496 49.921 138.02 151.14 164.28 205.46 26.262-54.316 97.782-155.54 164.28-205.46 47.98-36.021 125.72-63.892 125.72 24.795 0 17.712-10.155 148.79-16.111 170.07-20.703 73.984-96.144 92.854-163.25 81.433 117.3 19.964 147.14 86.092 82.697 152.22-122.39 125.59-175.91-31.511-189.63-71.766-2.514-7.3797-3.6904-10.832-3.7077-7.8964-0.0174-2.9357-1.1937 0.51669-3.7077 7.8964-13.714 40.255-67.233 197.36-189.63 71.766-64.444-66.128-34.605-132.26 82.697-152.22-67.108 11.421-142.55-7.4491-163.25-81.433-5.9562-21.282-16.111-152.36-16.111-170.07 0-88.687 77.742-60.816 125.72-24.795z"/></svg></a></div></div><h2 id="opentype-features"><a href="#opentype-features" class="header-link">OpenType Features</a></h2><p>Modern fonts come with hidden attributes that modify their look in subtle ways. Some examples are making the <code>4</code> glyph have an open back, making the <code>6</code> and <code>9</code> glyphs have straight tails rather than curved, and many more.</p><p>On the web, you can activate these features with well-defined, documented, CSS modifiers. It's very easy to load in a font, say you want the alternate G glyph, and move on! Here's the very <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Guides/Fonts/OpenType_fonts">lengthy documentation</a> from Mozilla for that.</p><p>I've used these features a couple of times previously, once for replicating the beautiful typography that Xcode uses for its line number gutter. A while ago, for CodeEdit, we were stumped as to how Xcode was making their line number font have open fours, straight tailed sixes and nines, until we found the following in a different open-source project.</p><pre><code class="language-swift">func rulerFont() -&gt; NSFont {
    /// Set the open four
    let alt4: [NSFontDescriptor.FeatureKey: Int] = [
        .selectorIdentifier: kStylisticAltOneOnSelector,
        .typeIdentifier: kStylisticAlternativesType
    ]
    
    /// Set alternate styling for 6 and 9
    let alt6and9: [NSFontDescriptor.FeatureKey: Int] = [
        .selectorIdentifier: kStylisticAltTwoOnSelector,
        .typeIdentifier: kStylisticAlternativesType
    ]
    
    let features = [alt4, alt6and9]
    let descriptor = font.fontDescriptor.addingAttributes([.featureSettings: features, .fixedAdvance: fontAdvance])
    return NSFont(descriptor: descriptor, size: 0) ?? font
}
</code></pre><p>We were not OpenType experts, so this tipped us off that we were missing something. This led us down a rabbit hole of figuring out exactly what the font was, including what features, attributes, and sizes it had until we had it <em>perfect</em>.</p><blockquote><p>Eventually we were able to perfectly replicate the Xcode font, it's hilariously specific but pixel perfect, <a href="https://github.com/CodeEditApp/CodeEditSourceEditor/blob/main/Sources/CodeEditSourceEditor/Extensions/NSFont/NSFont%2BRulerFont.swift">check it out</a>.</p></blockquote><p>This still left me wondering how I could find what features a font supported, or how in the world you could find those seemingly random C identifiers.</p><h2 id="finding-which-features-a-font-supports"><a href="#finding-which-features-a-font-supports" class="header-link">Finding Which Features a Font Supports</a></h2><p>I'm now working on a version 2.0 of my budgeting app <a href="https://openbudget.us">OpenBudget</a>, and while designing in Sketch I found that to make some small currency labels legible, I wanted three specific OpenType features:</p><ul><li>Open Currency.</li><li>Open Fours.</li><li>Straight Six and Nine.</li></ul><p>Sketch handily lets you view all the available options for a font in a nice menu with labels and checkboxes. However, if you try and google "UIFont OpenType Open Four" you'll be sorely disappointed. I knew that CoreText had constants somewhere for each feature, but looking up the <a href="https://github.com/bruce0505/ios7frameworks/blob/master/CoreText/SFNTLayoutTypes.h">CoreText headers</a> yields a list of undocumented constants. As it turns out Apple's CoreType predates OpenType, so the identifiers don't match to what OpenType calls them and Apple has no documentation for what each of them do.</p><p>Eventually I stumbled upon the CoreText documentation for font features and found the following magical CoreText function.</p><pre><code class="language-swift">func CTFontCopyFeatures(_ font: CTFont) -&gt; CTArray?
</code></pre><p>Every font in Cocoa stores a list of <em>every</em> supported feature in their features array. If you pass a <code>UIFont</code> or <code>NSFont</code> to this function (thank goodness for class bridging) you'll find a map like the following.</p><pre><code class="language-bash">{
    CTFeatureTypeIdentifier = 35;
    CTFeatureTypeName = "Alternative Stylistic Sets";
    CTFeatureTypeSelectors =     (
                {
            CTFeatureOpenTypeTag = ss01;
            CTFeatureOpenTypeValue = 1;
            CTFeatureSelectorIdentifier = 2;
            CTFeatureSelectorName = "Straight-sided six and nine";
        },
                {
            CTFeatureOpenTypeTag = ss02;
            CTFeatureOpenTypeValue = 1;
            CTFeatureSelectorIdentifier = 4;
            CTFeatureSelectorName = "Open four";
        },
                {
            CTFeatureOpenTypeTag = ss03;
            CTFeatureOpenTypeValue = 1;
            CTFeatureSelectorIdentifier = 6;
            CTFeatureSelectorName = "Vertically centered colon";
        },
                {
            CTFeatureOpenTypeTag = ss04;
            CTFeatureOpenTypeValue = 1;
            CTFeatureSelectorIdentifier = 8;
            CTFeatureSelectorName = "Open currencies";
        },
    );
},
</code></pre><p>You may note here, that these labels indicate these constants are exactly what I'm looking for.</p><h2 id="mapping-selectors-to-identifiers-to-uifont"><a href="#mapping-selectors-to-identifiers-to-uifont" class="header-link">Mapping Selectors To Identifiers To UIFont</a></h2><p>Now, if you take the map you printed from your font and try to put it into a features array, you'll quickly realize that you don't have a whole lot of information. Here's how to read that map to find exactly what to put in your Swift code.</p><p>For creating a <code>UIFont</code> or <code>NSFont</code>, we need to create an array of attribute dictionaries. Here's what they look like.</p><pre><code class="language-swift">let attribute: [UIFontDescriptor.FeatureKey: Int] = [
    .type: // The type of attribute we're adding
    .selector: // What option we're enabling (or disabling) on the type.
]
</code></pre><blockquote><p>For <code>NSFont</code>, the type and selectors are named <code>selectorIdentifier</code> and <code>typeIdentifier</code>.</p></blockquote><h3 id="features-with-unnamed-constants"><a href="#features-with-unnamed-constants" class="header-link">Features With Unnamed Constants</a></h3><p>You'll see the top-level dictionary here has a <code>CTFeatureTypeIdentifier</code> key. This key maps to the "Feature types" enum from those <a href="https://github.com/bruce0505/ios7frameworks/blob/master/CoreText/SFNTLayoutTypes.h">CoreText headers</a> I referenced earlier. That's the <code>.type</code> we're looking for. To find the selector, we'll take a look at the <code>CTFeatureOpenTypeTag</code>. The <code>CTFeatureOpenTypeTag</code> (if it's available on your feature) maps to a constant we can provide to CoreText to indicate if we want the feature on or off. That constant looks like:</p><pre><code class="language-swift">kStylisticAlt[Number][On/Off]Selector
</code></pre><p>If we look at the map from earlier, to enable "Open currencies" we have the dictionary:</p><pre><code>{
    CTFeatureOpenTypeTag = ss04;
    CTFeatureOpenTypeValue = 1;
    CTFeatureSelectorIdentifier = 8;
    CTFeatureSelectorName = "Open currencies";
},
</code></pre><p>So we'll want the fourth selector, and we'll want it on. So we get the constant.</p><pre><code class="language-swift">kStylisticAltFourOnSelector
</code></pre><p>And we already determined the type from the parent (number 35) which maps to the <code>kStylisticAlternativesType</code> constant in the CoreText headers. Combining this gives us the resulting Swift dictionary.</p><pre><code class="language-swift">let altCurrency: [UIFontDescriptor.FeatureKey: Int] = [
    .selector: kStylisticAltFourOnSelector,
    .type: kStylisticAlternativesType
]
</code></pre><h3 id="features-with-named-constants"><a href="#features-with-named-constants" class="header-link">Features With Named Constants</a></h3><p>There's a second case here, you'll likely see other font features that don't have the number-based constants. Instead, those dictionaries will look like:</p><pre><code class="language-swift">{
    CTFeatureTypeExclusive = 1;
    CTFeatureTypeIdentifier = 37;
    CTFeatureTypeName = "Lower Case";
    CTFeatureTypeSelectors =     (
                {
            CTFeatureSelectorDefault = 1;
            CTFeatureSelectorIdentifier = 0;
            CTFeatureSelectorName = Default;
        },
                {
            CTFeatureOpenTypeTag = smcp;
            CTFeatureOpenTypeValue = 1;
            CTFeatureSelectorIdentifier = 1;
            CTFeatureSelectorName = "Small Capitals";
        }
    );
},
</code></pre><p>For these, head to the CoreText headers, find your type constant (37 here, <code>kLowerCaseType</code>) and search the headers for that constant. The options here will have their own enum. This is the case for all options that have <em>set</em> standard options. For the previous example some fonts may have different features enabled by different numbers there. Here, the options are known beforehand.</p><pre><code class="language-c">/*
 *  Summary:
 *    Selectors for feature type kLowerCaseType
 */
enum {
  kDefaultLowerCaseSelector     = 0,
  kLowerCaseSmallCapsSelector   = 1,
  kLowerCasePetiteCapsSelector  = 2
};
</code></pre><h2 id="conclusion"><a href="#conclusion" class="header-link">Conclusion</a></h2><p>After printing the font features and doing this investigating, I now have the following extension for <code>UIFont</code>.</p><pre><code class="language-swift">import UIKit

extension UIFont {
    public func currency() -&gt; UIFont {
        /// Set the alt currency
        let altCurrency: [UIFontDescriptor.FeatureKey: Int] = [
            .selector: kStylisticAltFourOnSelector,
            .type: kStylisticAlternativesType
        ]

        /// Set the open four
        let alt4: [UIFontDescriptor.FeatureKey: Int] = [
            .selector: kStylisticAltOneOnSelector,
            .type: kStylisticAlternativesType
        ]


        /// Set alternate styling for 6 and 9
        let alt6and9: [UIFontDescriptor.FeatureKey: Int] = [
            .selector: kStylisticAltTwoOnSelector,
            .type: kStylisticAlternativesType
        ]

        let newDescriptor = fontDescriptor.addingAttributes([
            .featureSettings: [alt4, alt6and9, altCurrency]
        ])
        return UIFont(descriptor: newDescriptor, size: pointSize)
    }
}
</code></pre><p>Which gives me this beautiful typography for my currency labels.</p><img src="./typography.png" alt="typograph-screenshot"/><p>This is one of the many changes I'm working on for version two of OpenBudget. Modifying fonts slightly for labels like this that are common throughout my app is essential for making everything legible.</p><p>It's a little annoying that CoreText doesn't map nicely to OpenType feature names, but honestly it's understandable. I think there's an opportunity here for some lookup tool that could select a font, open it up, and list all the available features with a preview. But honestly, now that I know how to find those features, it's such a small one-time task that I don't really mind doing it by hand.</p><hr></hr><div class="article-footer"><p>Feb 6, 2026</p><div class="avatar" href="/about.html"><a href="/about.html"><img alt="Avatar Image" height="24" src="/assets/avatar.webp" width="24"></img><span>Khan Winter</span></a>·<a href="https://bsky.app/profile/khanwinter.com" target="_blank"><svg aria-label="Bluesky" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 530" version="1.1"><path d="m135.72 44.03c66.496 49.921 138.02 151.14 164.28 205.46 26.262-54.316 97.782-155.54 164.28-205.46 47.98-36.021 125.72-63.892 125.72 24.795 0 17.712-10.155 148.79-16.111 170.07-20.703 73.984-96.144 92.854-163.25 81.433 117.3 19.964 147.14 86.092 82.697 152.22-122.39 125.59-175.91-31.511-189.63-71.766-2.514-7.3797-3.6904-10.832-3.7077-7.8964-0.0174-2.9357-1.1937 0.51669-3.7077 7.8964-13.714 40.255-67.233 197.36-189.63 71.766-64.444-66.128-34.605-132.26 82.697-152.22-67.108 11.421-142.55-7.4491-163.25-81.433-5.9562-21.282-16.111-152.36-16.111-170.07 0-88.687 77.742-60.816 125.72-24.795z"/></svg></a></div></div></article></div><footer><p>Copyright &copy Khan Winter 2026</p><p><a href="https://github.com/thecoolwinter/blog">Built In Swift</a></p><p><a href="https://bsky.app/profile/khanwinter.com" rel="me" target="_blank">Bluesky</a> | <a href="https://khanwinter.com/feed.rss">RSS</a></p></footer></body></html>