<!DOCTYPE html><html><head><meta charset="utf-8"/><meta content="width=device-width, initial-scale=1, maximum-scale=1" name="viewport"/><meta content="dark light" name="color-scheme"/><title>Khan's Blog</title><link href="/resources/index.css" rel="stylesheet"/><link href="/resources/prism.css" rel="stylesheet"/><link href="/resources/code-theme.css" rel="stylesheet"/><script src="/resources/index.js"></script><script src="/resources/prism.js"></script></head><body><div class="content"><article><h2>Sorting Objects In A DB</h2><p>Lists of objects can often be sorted by a variable, eg calendar events are often sorted by the date they are for. Like so:</p><pre><code class="language-plaintext">Event 1: 10:00 AM
Event 2: 11:00 AM
Event 3: 12:00 PM
</code></pre><p>Sometimes though, we need to sort objects in a list that don't have an easy way to sort, or we need to allow users to sort the objects to their desire. The user will most likely expect his/her sort order to be kept, and we also can't just store an Array of objects in a db.</p><p>The other problem is if we give all the objects a number value to sort by, we can't update <u>every single object</u> in the database with a new sort number. That's just impractical and a waste of compute time and energy.</p><p>The solution is to sort the items by a <code>Double</code> variable. The objects will look basically like this at first:</p><pre><code class="language-plaintext">Item 1: 10.0
Item 2: 20.0
Item 3: 30.0
</code></pre><p>When the user moves Item 3 up a slot, we just give it a number between items 1 and 2, like this:</p><pre><code class="language-plaintext">Item 1: 10.0
Item 3: 25.0 &lt;- Inserted here
Item 2: 20.0
</code></pre><p>If a user moves Item 3 back down, we just add 10.0 to the biggest item's order, and get the list we started out with:</p><pre><code class="language-plaintext">Item 1: 10.0
Item 2: 20.0
Item 3: 30.0
</code></pre><p>Finally, if the user moves Item 3 to the top of the list, we find a number between <code>0.0</code> and Item 1's order, and give it to Item 3:</p><pre><code class="language-plaintext">Item 3:  5.0 &lt;-- Halfway between 0 and 10
Item 1: 10.0
Item 2: 20.0
</code></pre><p>Pretty simple! We don't have to update every single item in the list, and <code>Double</code>s can be divided for a long time, so it will be rare to run out of space between items in the list.</p><p>This article will give an example of how to give users the ability to sort items and keep the sort order using Core Data in SwiftUI. This same method applies to any database/UI framework that allows you to sort your items by a <code>Double</code> type.</p><blockquote><p>There's also a fully functional example project <a href="https://github.com/thecoolwinter/SortDBExample">available for download here</a> that implements the ideas talked about.</p></blockquote><h2>Order Variable</h2><p>The main idea behind this solution is having a variable on all our objects in the list that's a <code>Double</code> type. For this example, say we have a list of items that we're going to allow the user to sort at will. The <code>Item</code> object may look something like this:</p><pre><code class="language-swift">struct Item {
    var id: UUID = UUID()
    var label: String
    var order: Double
}
</code></pre><p>Notice that we're adding an <code>order</code> variable as type <code>Double</code> to this object. In Core Data, this can be done super easily by just adding a variable of type <code>Double</code> to your .xcdatamodeld file.</p><p>When we go to fetch the <code>Todo</code>s we'll just sort them by the <code>order</code> variable. For Core Data this looks like this:</p><pre><code class="language-swift">@FetchRequest(sortDescriptors: [NSSortDescriptor(keyPath: \Item.order, ascending: true)], animation: .default)
private var items: FetchedResults&lt;Item&gt;
</code></pre><h2>Updating The Order</h2><p>There are 2 pieces of code we need to modify to make this actually work:</p><ol><li>When an <code>Item</code> is added</li><li>When an <code>Item</code> is moved</li></ol><h3>Added</h3><p>When an <code>Item</code> is added, we need to give it an initial order value. The code may look something like below, where I'm just getting the biggest order value, and adding more onto it for the new object. If there aren't any <code>Item</code>s I just give it a value of <code>100.0</code></p><pre><code class="language-swift">func addItem() {
    withAnimation {
        let newItem = Item(context: viewContext)
        newItem.label = "New Item!"

        if items.count &gt; 0 { // Check if there are items
            newItem.order = items.last!.order + 25.0 // Add some more to the order
        } else {
            newItem.order = 100.0 // Give some padding from 0.0 for later
        }

        try! viewContext.save()
    }
}
</code></pre><p>Awesome, now when items are added they will automatically go to the bottom of the list. If there are no items, we'll give ourselves some padding numerically for the next case.</p><h3>Moved</h3><p>When an item is moved, things get a little more tricky. There are 3 paths here to handle:</p><ol><li>The item is moved to the top of the list</li><li>The item is moved to the bottom of the list</li><li>The item is put somewhere in the middle</li></ol><p>We'll always need to find an order value between two values to insert the item somewhere.</p><p>For the three cases the <code>upper</code> and <code>lower</code> order values will be between:</p><ol><li>0.0 -&gt; next list item</li><li>last list item -&gt; last list item + 100.0</li><li>Next destination list item -&gt; destination list item</li></ol><p>In swift this looks like the following code</p><pre><code class="language-swift">var upper: Double
var lower: Double

if destination == items.count {
    print("Appending to the end of the list")
    lower = items.last!.order
    upper = items.last!.order + 100.0
} else if destination == 0 {
    print("Inserting into the begining")
    lower = 0.0
    upper = items.first?.order ?? 100.0
} else {
    print("Inserting into the middle of the list")
    // Find the upper and lower sort around the destination and make some sort orders
    upper = items[destination - 1].order
    lower = items[destination].order
}
</code></pre><p>Then, we can get numbers between the upper and lower limits like</p><pre><code class="language-swi">var newOrders: [Double] = stride(from: lower, to: upper, by: (upper - lower)/Double(sourceItems.count + 1)).map { $0 }
newOrders.remove(at: 0)
</code></pre><blockquote><p>We're handling the case where we're moving more than one item too. So if two items are inserted between 10.0 and 20.0 we should generate 12.5 and 17.5 to insert both the items in the correct spot.</p></blockquote><p>Then, its a simple matter of updating the sort order of the objects!</p><pre><code class="language-swift">var i = 0
source.forEach { index in
    items[index].order = newOrders[i]
    i += 1
}

try! viewContext.save()
</code></pre><p>Done! üéâ</p><p>Here's the code from the example project in action.</p><video width="400" controls>
  <source src="/2021/08/07/video.mp4" type="video/mp4">
  Your browser does not support the video tag.
</video></article></div><footer><p>Copyright ¬©Ô∏è Khan Winter 2024</p><p>Built In Swift</p><p><a href="https://twitter.com/thecoolwinter" rel="me" target="_blank">Twitter</a> | <a href="https://threads.net/thecoolwinter" rel="me" target="_blank">Threads</a> | <a href>RSS</a></p></footer></body></html>